# 第10章 定义泛型函数和结构

## 泛型函数，及参数类型推断

类似于C++语言中的函数模板，Rust支持泛型函数(C语言不允许编写泛型函数)  
利用T类型参数来参数化泛型函数，而不是声明具体的函数；仅当在后续代码中，将T指定具体类型时，该函数才成为具体函数  

```rust
    fn f<T>(ch:char, num1:T, num2:T) -> T {
        if ch == 'a' {num1}
        else {num2}
    }
    // 1
    let a:i16 = f_def::<i16>('a', 37, 41);
    let b:f64 = f_def::<f64>('b', 37.2, 41.1);
    println!("a={}, b={}", a, b); // a=37, 41.1
    // 2
    let c:i16 = f_def('a', 37, 41);
    let d:f64 = f_def('b', 37.2, 41.1);
    println!("c={}, d={}", c, d); // c=37, 41.1

    // T, V
    fn f<T, V>(_a: T, _b: V){}
```

上述代码中的第2中写法，是简写形式。编译器会根据传入的参数进行类型推断，如果两参数类型一致，就认为合法  

## 泛型结构

类似于C++语言中的类模板和结构模板，Rust支持泛型结构和泛型元组结构(C语言不允许使用泛型结构)  

```rust
    struct S<T1, T2>{
        c:char,
        n1:T1,
        n2:T1,
        n3:T2
    }
    ...
    let _s1 = S{'a', 34, 782, 0.02};
    let _s2 = S::<u16, f32>{'a', 34, 782, 0.02};

    //
    struct SE<T1, T2>(char, T1, T1, T2);
    ...
    let _se1 = SE('a', 34, 782, 0.02);
    let _se2 = SE::<u16, f32>('a', 34, 782, 0.02);
```

### 泛型机制

第一阶段，编译器扫描源代码。一旦发现泛型**函数声明**，它在其数据结构中加载该函数的内部表示形式(以其所有反省形式加载)，仅做语法检查  
第二阶段，编译器再次扫描代码。一旦发现泛型**函数调用**，它就检查调用方与声明方的相应内部表示之间的关联。确定对应关系有效后，在其数据结构中加载该对应关系  
第三阶段，编译器扫描所有的泛型函数调用。根据调用方及具体的参数，来确定一个具体的函数类型。然后，编译器生成泛型函数的具体版本，并将针对泛型函数的调用，替换为具体函数的调用  
第四阶段，编译此代码。如果针对泛型的调用，指定了不同的类型，编译器将生成两个不同的具体类型；相反地，如果泛型的调用方指定的类型一致，编译器只会生成一个具体的函数类型  

通过上面的编译过程，可以得出：  

- 泛型代码的编译，要比非泛型慢  
- 编译后的具体类型，进行了高度优化，运行性能更高  
- 容易“代码膨胀”  

上述机制，也适用于泛型结构和元组结构  

泛型数组和向量，本就视为泛型类型  
数组是Rust语言自带的，但向量是在Rust标准库中定义的结构  

## 泛型枚举

泛型枚举在Rust标准库中经常使用  
鉴于Rust里没有异常(exception)的概念。
当试图在空向量上调用pop()方法(弹出一个元素)，某些语言会直接崩溃或产生未知结果；Rust会返回一个MyOption<T>类型的值  
该返回值的标准库定义如下：

```rust
    enum MyOption<T> {
        Some(T),
        None,
    }
```

> 上述定义的意思：这是T类型的可选值。它可以选择是T，还可以选择什么都不是。可以是某类型，也可以什么都不是。如果它是什么的话，那它就是T  

## 错误处理

Rust标准库还定义了以下一个泛型枚举，以处理函数无法返回期望类型的值  

```rust
    enum Result<T, E> {
        Ok(T),
        Err(E),
    }
```

Result枚举和Option枚举很相似  
只是Option在缺少结果时，表示为None；而Result支持添加一个描述此异常的值  

## 枚举标准实用程序函数

针对Option和Result的泛型类型，使用match获取结果多有不便  
Rust标准库包含了一些实用函数，以简化Option和Result的解码:  

- result1.is_ok()
- result1.is_err()
- result1.unwrap()

unwrap()函数有可能产生紧急处理的消息
