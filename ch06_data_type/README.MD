# 第6章 使用基本类型

## 整数的进制基数

十六进制，十进制，八进制，二进制不同的基数表示及下划线  

```rust
    let hexadecimal_ = 0x_00FF_f7a3;       // 十六进制, 基数是x
    let octal_ = 0o_777_205_162;           // 八进制, 基数是o
    let binary_ = 0b_0110_1001_1111_0001;  // 二进制, 基数是b
    let mut decimal_ = 1_234_567;          // 十进制
    println!("hexadecimal_={}, octal_={}, binary_={}, decimal_={}", hexadecimal_, decimal_, octal_, binary_);
    // 
```

十六进制代表数字的字母不区分大小写；  
但是数字基数里的字母必须小写  

> 字节的表示：let a:char = b'A';  //只能表示u8类型

## 指数

指数3 4_.56_e3表示整数34560；其中，字母e(exponential)的前面是尾数(3 4_.56_)，后面是指数(3)  

## 整数相关

Rust由十种不同的整数类型，和两种浮点数类型  
|类型|占用字节|最小值|最大值|举例|
|:---|:---:|:---|:---|:---|
|i8|1|-128|+127|let a:i8 = 127;|
|i16|2|-32_768|+32_767|let a:i16 = 32_767;|
|i32|4|-2_147_483_648|+2_147_483_647|默认的整数类型，let a:i32 = 2_147_483_647;|
|i64|8|-2^63^|+2^63^-1|let a:i64 = 9_223_372_036_854_775_807;|
|isize|4或8|32bit: -2_147_483_648, 64bit: -2^63^|32bit: +2_147_483_647, 64bit: +2^63^-1|let a:isize = 100; // max value depends on the target architecture|
|u8|1|0|+255|let a:u8 = 255;|
|u16|2|0|+65_535|let a:u16 = 65_535;|
|u32|4|0|+4_294_967_295|let a:u32 = 4_294_967_295;|
|u64|8|0|+2^64^-1|let a:u64 = 18_446_744_073_709_551_615;|
|usize|4或8|0|32bit: +4_294_967_295, 64bit: +2^64^-1|let a:usize = 100; // max value depends on the target architecture|
|f32|-|-|-|let a:f32 = 1e38; 等效C语言的float|
|f64|-|-|-|默认的浮点类型，let a:f64 = 1e308; 等效C语言的double。|

- 现代计算机用于算术和数据传输的指令，只能有效地应用于具有8，16，32和64位的数字  
- 处理大小为2的幂的对象时，内存管理效率更高  
- 只包含几种类型，编译器可以生成更紧凑的代码，适合CPU缓存  

> 如果检查有符号的整数x是否在(包括)0和(排除)正整数n之间，则编写布尔表达式0<=x && x<n；如果x是无符号整数，可以简单的用x<n检查即可  

用作数组或向量的索引的最有效类型：  

- 16位计算机上，使用16位无符号整数
- 32位计算机上，使用32位无符号整数
- 64位计算机上，使用64位无符号整数

Rust包含的usize和isize就是为数组或向量的索引准备的  

## 类型推导

有时候，变量或表达式并不需要显示地指定数据类型，编译器可以从涉及的上下文推导(deduce)或推断(infer)出她的类型  

类型推导，师再程序编译时完成，并为每个变量指定一个具体的受约束类型  
如果推导失败，则会编译失败；但，如果推断出数据类型为整型，但无法约束为具体的整数类型，则采用“默认”类型i32类型  

```rust
    let m = 8;
    let n = 8_000_000_000;
    println!("m={}, n={}", m,n);
    // m=, n=
    // n超出默认类型i32的最大值
```

## 浮点类型

目前，Rust只有两种浮点类型：f32和f64，其中f64时默认的浮点数类型  
f32类型的数字有24位尾数，可精确表示所有最大不超过约1600万的整数；十进制下，每个值几乎都有7个有效数字  
f64的数字有53位尾数，可精确表示所有最大不超过约900亿的整数；十进制下，每个值几乎都有16个有效数字  

## 显示转换

as运算符可以显示地为变量指定一个新的数据类型；但可能存在数据丢失的情况  
因为，Rust是从目标对象提取足够的最低有效位以表示指定的类型，并生成该值作为表达式的结果  

## 布尔值和字符

布尔型用bool表示，值只能为 true 或 false；多用于if或while语句的条件  
布尔类型和数值类型之间的转换：truthy!=0或b as u8；只有数值0和1可以转换为布尔类型  

字符型用char表示，大小为4个字节(C语言只占有1个字节)，代表Unicode标量值，这意味着它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格在Rust中都是有效的char值。Unicode值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （包括两端）。源程序与命令行的文字编码不一致，所以在Rust中字符串和字符都必须使用 UTF-8 编码，否则编译器会报错  
数字0到255之间的数字都有一一对应的unicode字符，因此可将此区间内的数字，转换为任意数量的u8类型的字符  

```rust
    // 必须先将i转换位u8类型，然后再转换为char
    for i in 0..256{
        print!("{}:[{}], ", i, i as u8 as char);
    }
```

## 空元组

空元组()，对应于C语言的void和JavaScript的undefined，表示没有类型信息  

## 复合类型

元组，数组和向量  
元组用一对(...)包括的一组数据，可以包含不同种类的数据  

```rust
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    // tup.0 等于 500
    // tup.1 等于 6.4
    // tup.2 等于 1
    let (x, y, z) = tup;
    // y 等于 6.4
```

## 数组和向量类型

如果更改数组或向量项的类型，则也会隐式更改数组和向量的类型  
如果更改包含项的数量，则会隐式更改数组的类型，而不会更改向量的类型  

显示化的定义数组和向量类型：

```rust
    let array1: [char;3] = ['x', 'y', 'z'];
    let array2: [f32;200] = [0f32; 200;];
    let vec1: Vec<char> = vec!['x', 'y', 'z'];
    let vec2: Vec<i32> = vec![0; 5000];
```

## 常数

```rust
    const N:usize = 20;
    let arr = [0; N];
    println!("arr[1]={}", arr[1]);
```

## 发现表达式类型

```rust
    let a:bool = 4u32/3u32;
    let b:bool = 4/3;
    /*
    1 |     let a:bool = 4u32/3u32;
    |           ----   ^^^^^^^^^ expected `bool`, found `u32`
    |           |
    |           expected due to this
    2 |     let b:bool = 4/3;
    |           ----   ^^^ expected `bool`, found integer
    |           |
    |           expected due to this
    */
```
